# Why React

- 解决传统方法的复用性问题
- 解耦了 Dom 操作和组件
- 编码方式优化
- 使用虚拟 Dom，对性能进行了优化

# 组件

## props

- props 的格式校验

```js
import PropTypes from "prop-types";
propsType = {
  name: PropTypes.string.isRequired,
};
```

- props 的默认值（props 未传时使用）

```js
Component.defaultProps = {};
```

## state

使用 setState 进行数据更新：

```js
this.setState({
  name: 'Tom
})

this.setState((prevState, props) => ({ name: prevState.name }))
```

setState 的第二个参数，可传入在 state 更新后的 callback 操作

## 组件样式

- className
  - 有第三方库 className，用于动态更新 class
  - 可使用 link 标签加载全局样式
  - 也可以使用 import 加载仅当前组件生效的样式文件。在渲染时，会在 className 前增加前缀，比如`_1Fx2bq_container`
- css-in-js

## 生命周期

生命周期主要指类组件的创建到销毁过程；函数组件内没有状态，亦没有生命周期

### 挂载阶段

construct --> getDerivedStateFromProps --> render --> React 更新 DOM 和 refs --> ComponentDidMount

- construct

  - 接入 props
  - 执行 state 初始化
  - 进行方法绑定（什么时候需要执行？见 this 处理）
  - 先执行 super

- getDerivedStateFromProps（使用的少）

  - 在**每次渲染前**都会进行调用，传入 props 和 state，当返回对象时，该对象会用于更新 state
  - 主要用于 props 变化时更新 state
  - 该方法是静态方法（static），故无法在方法中使用 this

- ComponentDidMount
  - 在组件挂载（即插入 DOM 树）时调用

### 更新阶段

> 新的 props、setState、forceUpdate 都会引起组件的更新。

getDerivedStateFromProps --> shouldComponentUpdate --> render --> getSnapshotBeforeUpdate --> React 更新 DOM 和 refs --> ComponentDidUpdate

- shouldComponentUpdate

  - 传入 nextProps 及 nextState，返回布尔值
  - 若返回 false，后续逻辑不在执行（后续 React 版本可能不支持）
  - 可在这里用于性能优化

- getSnapshotBeforeUpdate
  - 最近一次渲染输出（提交到 DOM 节点）前调用
  - 传入 prevProps、prevState，返回快照或 null

### 卸载阶段

componentWillUnmount

## 事件处理

React 事件中，必须显式的调用 preventDefault 来组织事件的默认行为。

## this 处理

**ES6 中的 class 不会为方法自动绑定 this 到当前对象。**

处理方案：

- 箭头函数
  多次 render，会创建多个处理函数。

```js
<div onClick={() => this.handleClick} />
```

- 函数绑定

```js
construct(props) {
  super(props);
  this.handleClick = this.handleClick.bind(this);
}
```

- class fields

```js
class Component extends React.Component {
  handleClick = () => {};
}
```

## 表单

### 受控组件

表单元素的值由 React 来管理。

```js
<div value={this.state.value} onChange={this.handleChange} />
```

### 非受控组件

表单元素的状态依然由表单元素自己管理。

```js
this.inputRef = React.createRef()

<div ref={this.inputRef} />
```

# Context

是 React 中的特殊对象，为组件间的传值提供了新方式。常用于组件层级较深时的数据传递。

```js
// Context创建
const ThemeContext = React.createContext('light')

// 最外层组件
<ThemeContext.Provider value='dark' />

// 最底层组件
static contextType = ThemeContext

return <Button theme={this.context} />
```

- React.createContext

  - 用于创建 Context 对象，传入参数作为 Context 的默认值
  - 默认值只在外层无 Provider 包裹时使用

- ThemeContext.Provider

  - 接收 value 作为 Context 的值
  - 消费组件：会被 Provider 组件包裹，并使用 value 属性的组件

- 消费组件使用 Context 方法 - class.contextType
  - 先设置 class.contextType 为 React.createContext 声明的 Context 对象
  - 通过 this.context 来访问 Context 的值

> 那我要怎么去修改 Context 的值？
>
> - 修改 ThemeContext.Provider 中 value 传入的值即可

- Context.Consumer

```js
<Context.Consumer>
  {(value) => {
    /** 基于context值进行渲染 */
  }}
</Context.Consumer>
```

# 高阶组件

是一种开发技巧，本质是参数是组件，返回值是组件的一个函数。

> 在有 hooks 的情况下，高阶组件是否还需要？

## 反向继承

```js
const LOGHOC = Wrapper => {
  return class HOC extends Wrapper {
    render() {
      console.log('render)
      super.render()
    }
  }
}
```

## 常用场景

### 操作 props

### 通过 refs 访问实例

```js
construct(props) {
  super(props);
  this.ref = React.createRefs(props);
}

render() {
  return <Wrapper refs={this.ref} />
}
```

### 组件状态提升

在高阶组件中处理数据，并传入包装的组件。

### 其他元素包装组件

# 错误处理

组件中报错，会导致组件树渲染崩溃。

## 如何捕获错误

- React16 后新增 Error Boundary（主要监听 render 渲染过程中，包括生命周期中的错误）

```js
componentDidCatch(err, info) {
  // 可以执行副作用操作，比如错误上报
}

static getDerivedStateFormError(err) {
  // 更新state数据
  return {
    hasError: true
  }
}
```

## 函数执行或接口调用中的 Error，使用 try catch

> 城堡调研过，还有其他错误监听方法，不然每个组件都需要写一次错误监听，太麻烦了

# Fragment

简写为 `<></>`

# Portal

Portal 允许将子节点渲染到父组件之外的节点。比如将 Modal 弹窗渲染在 root 节点。

```js
FReact.createPortal(<Component />, this.rootDom);
```

> 其事件冒泡，还是按照 jsx 中组件的位置，不受 Portal 影响。

# 调和过程（需要补强）

原有 diff 算法，在 1000 个节点时，运算量可达 10 亿次。为了简化算法，提出了两个假设：

- 两个不同类型的元素会产生两个不同的树
- 开发者可以通过 key、props 来暗示哪些子元素在不同渲染下保持稳定

## diff 算法

- 首先比较树的根节点
- 对子节点进行递归比较，若类型不同，执行先销毁再创建的操作
- 为了优化，设计 key、props 的属性机制

## 权衡

- 内容切换时，尽量保证组件类型稳定
- key 应该是稳定的，并且在兄弟节点中唯一
